### 1:最左前缀法则

　　如果你的索引有多个字段,如图1所示,索引字段有 kq\_time, card\_no, kq\_type这三个字段(最左前缀就是按这三个字段的前后顺序进行排序的)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527210231524-1886848696.png)

 如果是三个查询条件中三个字段都用到了,如图二(严格按照最左前缀原则,查询条件顺序是使用了三个字段(kq\_time,card\_no,kq\_type)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527210921249-283585425.png)

 这是图二是使用了全部索引,三个字段的索引都用到了,key\_len的长度是165,看图三每个字段对应的长度,kq\_time的类型是datetime长度是8,card\_no的类型是varchar长度是50,kq\_type的类型是varchar长度是1,所有总长度是8+(50\*3+2)+(1\*3+2)=165(这个值是预估值,有时候不准确,下面就会出现此情况),所以所有的索引都走了,索引长度计算看图三

 ![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527211644775-349706803.png)

下面的图四,遵守了最左前缀原则,都走了部分索引kq\_time(遵守了最左前段法则,查询条件顺序kq\_time)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527213430501-368050114.png)

 再看图五,走了部分索引kq\_time和card\_no(遵守了最左前段法则,查询条件顺序kq\_time和card\_no)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527213558442-1468307556.png)

图六 (没有遵守最左前缀原则,查询条件跳过kq\_time字段,使用了后面的两个字段,所有不走索引)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527214321484-1150486527.png)

图七(遵守了最左前缀原则,kq\_time有了,后面没有card\_no,直接使用了kq\_type,所有索引只走了kq\_time)

![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527214656643-1893929935.png)

 ![](https://img2020.cnblogs.com/blog/1541798/202005/1541798-20200527220708288-482441355.png)

 在最后,总结一下什么最左前缀原则:查询从索引的最左前列开始并且不跳过索引中的列,通俗易懂的来说就是:带头大哥不能死、中间兄弟不能断