## 覆盖索引

覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。

理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引[叶子节点](https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020)存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。

理解方式二：是非聚集[复合索引](https://so.csdn.net/so/search?q=%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95&spm=1001.2101.3001.7020)的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段，也即，索引包含了查询正在查找的数据）

那我们如何知道，SQL有没有使用到覆盖索引呢，在MySql中，我们可以使用explain查询SQL的执行计划，如果使用了覆盖索引，在Extra字段会输出Using index，这就表示当前sql使用了覆盖索引  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606223451269.png)‘  
如何实现索引覆盖？

最常见的方法就是：将被查询的字段，建立到联合索引（如果只有一个字段，普通索引也可以）里去。

如以下这句sql，我在name字段建立了一个索引

EXPLAIN SELECT id,name FROM student

看它的执行计划，为Using index  
’![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606223541510.png)

这是因为索引叶子节点存储了主键id，而name也是索引，所以查询为覆盖索引。

当我们添加一个不是索引的字段时，那么就无法从索引树上查询，必须回表查询出这个字段

EXPLAIN SELECT id,name,age FROM student

结果如下

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606223606292.png)

注意：覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B-tree索引做覆盖索引。